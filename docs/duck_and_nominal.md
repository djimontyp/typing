## Качина типізація

:   Важливо лише, які операції він фактично підтримує.  
    Якщо я можу викликати метод birdie.quack(), то в цьому контексті birdie є качкою.  
    За визначенням, качина типізація вступає в дію тільки на етапі виконання, коли робиться спроба виконати якусь операцію об'єкта.  
    Це більш гнучкий підхід, ніж номінальна типізація, але розплачуватися за гнучкість доводиться великою кількістю помилок на етапі виконання.

    !!! info
        Качина типізація – неявна форма структурної типізації, яка в Python ≥ 3.8
        підтримується також завдяки додаванню **typing.Protocol**.

    ??? example "Code"
        ```python
        --8<-- "docs/code/birds.py"
        ```
        ```bash
        ❯ mypy ./birds.py
        /birds.py:19: error: "Bird" has no attribute "quack"  [attr-defined]
        Found 1 error in 1 file (checked 1 source file)
        ```
        ```bash
        ❯ birds.py
        Quack!
        Quack!
        Quack!
        Traceback (most recent call last):
        File "/birds.py", line 31, in <module>
            alert(woody)
        File "/birds.py", line 11, in alert
            birdie.quack()
            ^^^^^^^^^^^^
        AttributeError: 'Bird' object has no attribute 'quack'
        ```

## Номінальна типізація

:   Номінальна типізація, відома також як типізація за ім'ям, означає, що два типи вважаються різними, якщо вони мають різні назви, незалежно від того, чи мають вони однакову структуру чи ні.  
Це як якщо ви маєте два однакових автомобіля, але один з них названий "Toyota", а інший "Honda". Незалежно від того, що вони можуть виглядати і працювати однаково, вони вважаються різними, тому що мають різні назви.